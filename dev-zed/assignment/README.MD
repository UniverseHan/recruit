# ZIGBANG ZED Assignment

안녕하세요. 직방 ZED 팀 지원자 여러분. 지원해주셔서 감사합니다.

과제 설명 전 간단한 안내 말씀 드리겠습니다.

직방 ZED 팀은 유니티 엔진을 이용하여 직방에 있는 부동산 빅데이터들을

3D 정보로 시각화해주는 일을 하고 있습니다.

이와 관련하여 과제도 간단한 데이터를 이용해 3D 시각화로 진행하고 있습니다.

Github 의 fork 기능을 이용하여 개인 저장소로 복사해주신 다음 

코드를 작성 및 README.MD 파일 수정 후 개인 저장소의 URL을 채용 담당자에게 공유해주시면 됩니다.

최하단의 [문제 해결 방법] 섹션은 면접에 도움이 될 수 있도록

과제를 하면서 고민했던 부분, 해결방안 등에 대해 자유롭게 작성해주시면 됩니다.

## 과제 설명

- 과제는 유니티 2019.4.21f1 으로 작성합니다.

- Scenes/ZedScene.unity 씬에서 확인 가능하도록 작성부탁드립니다.

### 문제1) 단지에 있는 동의 폴리곤 데이터를 이용하여 런타임에 메쉬를 구성하여 렌더링해주세요.(40점)

샘플 데이터는 아래의 경로에 위치해 있습니다.

Assets/Samples/json/dong.json

다음과 같이 구성되어 있습니다.

```
API Response 구성
{
    success: boolean, // API 성공 여부
    code: number, // API 결과 코드
    data: [] // 동 데이터 배열
}

동 데이터 구성
{
    roomtypes: [], // 타입 데이터의 배열
    meta: {
        bd_id: number, // 동 id
        동: string, // 동 이름
        지면높이: number, // 지면으로 부터의 높이
    } // 메타 정보
}

타입 데이터 구성
{
    coordinatesBase64s: string[], // 폴리곤 데이터의 배열
    meta: {
        룸타입id: number // 타입 id
    }
}

폴리곤 데이터의 구성 (*중요*)
- float[] 을 byte[] 로 변환후 Base64 로 인코딩된 데이터
- float[] 는 3개씩 나누어 Vector3 의 x,z,y 에 매핑됩니다.
  ex) [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
  -> [Vector3(1.0, 3.0, 2.0), Vector3(4.0, 6.0, 5.0)]
- C# 의 Buffer.BlockCopy, Convert.FromBase64String 등의 함수를 이용하시면 됩니다.
```
**폴리곤 데이터 1당 유니티 좌표계의 1m 를 의미합니다.**

아래의 그림과 유사한 단지 구성이 되어야 합니다. 평형별 색상은 고려하지 않으셔도 됩니다.

![결과1](https://i.imgur.com/vcmmiid.png)



### 문제2) 문제1의 결과를 바탕으로 생성된 메쉬에 텍스쳐를 매핑합니다.(60점)

텍스쳐의 위치는 아래와 같습니다.

Assets/Samples/texture/buildingTester_d.png

텍스쳐는 아래와 같이 구성되어 있습니다.
![Texture](https://i.imgur.com/srIPHBq.png)


텍스쳐 매핑은 다음과 같습니다.

1번(앞) : 정점의 normal과 Vector3.forward의 각도가 y축을 기준으로 180 <= n && n <= 220 에 해당하는 경우

2번 : 1, 3을 제외한 모든 경우

3번(위, 아래) : 정점의 normal이 y축을 기준으로 Vector3.up || Vector3.down과 일치하는 경우


텍스쳐 파일을 자르지 않고 한장으로 그려야합니다. 

**한 층을 3m 로 가정하여 Material 의 SetTextureScale 값을 조정해주세요.**

**ex) 한 동의 높이가 10m 인 경우 = 10 / 3 = 3.3333 = 3층**

**Material.SetTextureScale("_BaseMap", new Vector2(1f, 3));**

아래의 그림과 비슷한 모양이 나와야합니다. 실 데이터와 차이가 있으므로 정확하게 일치하지는 않습니다.

![결과2](https://i.imgur.com/gbjA93E.png)

#### 평가기준

1. <b>아파트 단지에 텍스쳐 맵핑을 적용 (10점)

2. 주어진 텍스쳐 이미지를 문제에서 제시한 영역만큼 구분하여 적용 (20점)
   * 정점의 uv 좌표를 이용하여 구현해야 합니다. 텍스쳐 파일 나누어 구현하는 것은 인정되지 않습니다.

3. 적용된 텍스쳐를 문제에 제시한 방향 조건에 맞추어 적용 (30점)</b>

### 코드 설계시 우대되는 부분

유니티 라이프 사이클 함수 (Awake, Start, OnEnable, OnDisable, OnDestroy, Update) 이외의 직접 라이플 사이클을 구현 <b>(점수 획득한 문제에 가산점 +20점)</b>

MyFramework.cs 파일에 GameObject / Material 등의 리소스 생성 및 삭제가 구현되어야 합니다.

MyFramework.cs 파일에만 유니티 라이프 사이클 함수를 사용합니다.

리소스 생성 및 삭제의 순서가 명확해야합니다.

# 문제 해결 방법 (자유롭게 작성)
## JSON Load
단순하게 문제에서 설명된 방법을 사용하여 JSON객체를 로드 하였다. 서버의 응답을 담을 Response 객체를 만들어서 사용하였다.

## Float[] 파싱
문제에서 제시된 방법으로 byte[]를 순회하면서 정점들을 파싱 하였다.

## 정점 인코딩
문제에서 설명한 방법대로. Convert.FromBase64String() 함수와 Buffer.BlockCopy 함수를 사용하여 정점 하나에 float 3개씩 바이트 버퍼로 부터 추출 하였다.

## 정점 -> Mesh
처음엔 정점이 최적화 되었거나. 면당 4개의 정점을 사용하고 인덱스를 사용하여 매시가 구성되었을 것이라고 예상 하였다. 하지만 정점들은 단순히 폴리곤 단위로 전부 구성 되어 있었다.

## 폴리콘의 정점 익덱스 생성
정점들이 단순히 폴리콘바다 별도로 구성되어 있었기 때문에 인덱스는 순서대로 증가하기만 하면 되었다.

## 아파트의 높이 계산
단순히 모든 정점들을 순회하면서 계산하였다. maxY - minY = height

## 텍스처 uv매핑
텍스터를 자세히 들여다 보니 정사각형의 격자로 나누어져 있었고 이것의 숫자를세어 영역을 구분하였다. 예를들어 1영역이 차지하는 가로는 24블럭중 12개의 부분을 차지 하기때문에 u좌표의 경계를 1영역 블럭개수 / 전체 가로 블록개수 즉  12.0f / 24.0f로 계산하였다.

## 아파트 방향 계산
- normal 벡터 계산, 선형대수학 시간에 배운 공식 AXB / |AXB| = norm 공식을 이용하여 구할 수 있었다.
- 상,하 방향은 단순히 기준 벡터와의 내적을 이용하였고 내적이 1 이거나 -1이면 같은 방향이거나 반대방향임을 의미하므로. 위를 보고 있거나 아래를 보는 면으로 판단 할 수 있다.
- 아파타의 바라보는 방향을 바닥면과 수평이 아닐 수 있어, 우선 바닦면과 평행하게 프로젝션을 할 필요가 있으나 좌표 축으로 이루어진 평면이기 때문에 단순히 노멀 벡터의 y요소만 제거하여 구할 수 있었다.
- forware방향을 이루는 백터와 아파트면과의 각도는 내적공식을 이용하여 구할 수 있다. A*B = |A|*|B|cos@ 로 두고 @에 대해서 풀면 각도를 구할 수 있지만. cos의 범위는 0도 ~ 180도에대해 -1 ~ 1의 범위만 표현 할 수 있기 때문에 180도 이상을 계산 하려면 마이너스 값일때와 각도를 같이 고려해주어야 한다.

## 게임 오프젝트의 생성
- 유니티의 게임오브젝트를 코드를 통해 생성
- 렌너링을 위해 MeshFilter컴포넌트 추가.
- 화면에 보이기 위해 MeshRenderer를 추가하고 쉐이더와 텍스쳐를 추가
- 텍스처 매핑을 잘 적용하기 위해서는 Shader.Find()함수를 사용할때 결과를 체크해야 한다. `Shader.Find("Unlit/Texture")` 를 사용하여 구현 `Shader.Find("Standard")`는 동작 하지 않을 수도 있다.


# 개선할 사항
- 중복 정점들을 제거하고 인덱스를 사용하여 메모리를 절약할 수 있다. (하지만 텍스쳐를 구성하기 위해서는 다른 면은 별도의 정점을 사용해야 할것 같다..)
- 사실 모든 매쉬데이터가 거의 동일한 형태를 띄기 떄문에, 동일한 모양의 아파트는 동일한 정점을 가진 매쉬데이터를 사용하고 단순히 트렌스폼만 다르게 하여 최적호 할 수 있다.
- 데이터를 로드하는 부분과 매시를 만들어 내는 부분, 그리고 게임오브젝트를 생성하는 부분을 분리하여 코드를 좀 더 유연하고 읽기 쉽게 만들 수 있다.



